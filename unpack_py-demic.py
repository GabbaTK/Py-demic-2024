data = {'autoUpdater.py': 'from data import version\nfrom urllib.request import urlopen as uo\nfrom os import startfile, remove\nfrom os.path import exists\n\nupdaterCode = """\nfrom urllib.request import urlopen as uo\nimport time\n\ntime.sleep(1)\n\ndownloadUrl = "https://raw.githubusercontent.com/GabbaTK/Py-demic-2024/main/unpack_py-demic.py"\n\ndownload = uo(downloadUrl)\ndownload = download.read()\nexec(download)\n"""\nversionUrl = "https://raw.githubusercontent.com/GabbaTK/Py-demic-2024/main/version.txt"\n\ndef verify():\n    newVersion = uo(versionUrl)\n    newVersion = eval(newVersion.read())\n    \n    if newVersion > version:\n        print("A new version has been found, downloading...")\n\n        with open("update.py", "w") as update:\n            update.write(updaterCode)\n\n        startfile("update.py")\n\n        return True\n    else:\n        if exists("update.py"):\n            remove("update.py")\n', 'blank.json': '{\n    "size_x": 500,\n    "size_y": 500,\n    "people_scale": 10,\n    "people": 20,\n    "travel_speed": 2,\n    "randomness": 5,\n    "healed_time": 20,\n    "infected_time": 20,\n    "infective_chance": 70,\n    "lethality_chance": 20,\n    "spawn": [\n        {"start": [0, 0], "end": [200, 200], "probability": 25},\n        {"start": [300, 0], "end": [500, 200], "probability": 25},\n        {"start": [0, 300], "end": [200, 500], "probability": 25, "vaccinated": true},\n        {"start": [300, 300], "end": [500, 500], "probability": 25, "infected": true}\n    ]\n}', 'classes.py': 'import modules\nfrom math import sqrt\nfrom time import time\nfrom random import random, randint\nfrom copy import deepcopy as dc\n\nclass State:\n    def __init__(self):\n        self.type = "normal"\n        self.canInfect = False\n        self.canBeInfected = True\n        self.timeTillChange = 0\n        self.vaccineInfinite = True\n\n    def step(self, model, debugMode, id):\n        if self.timeTillChange < time():\n            if self.type == "infected":\n                self.type = "healed"\n                self.canInfect = False\n                self.canBeInfected = False\n                self.timeTillChange = time() + model.data.healedTime + model.randomness()\n\n                if modules.randomChance(model.data.lethalityChance):\n                    self.type = "dead"\n\n                    if debugMode:\n                        print(f"Person {id} changed type from infected to dead")\n                else:\n                    if debugMode:\n                        print(f"Person {id} changed type from infected to healed")\n            elif self.type == "healed":\n                self.type = "normal"\n                self.canInfect = False\n                self.canBeInfected = True\n\n                if debugMode:\n                    print(f"Person {id} changed type from healed to normal")\n\n            elif self.type == "vaccinated":\n                if self.vaccineInfinite:\n                    return\n                \n                self.type = "normal"\n                self.canInfect = False\n                self.canBeInfected = True\n\n                if debugMode:\n                    print(f"Person {id} changed type from vaccinated to normal")\n            \nclass Person:\n    def __init__(self):\n        self.id = 0\n        self.x = None\n        self.y = None\n        self.lastX = None\n        self.lastY = None\n        self.gotoX = None\n        self.gotoY = None\n        self.color = (255, 0, 0) # BGR\n        self.state = State()\n\n    def step(self, model, debugMode):\n        # Events regardless of type\n        if self.state.type == "infected":\n            self.color = (0, 0, 255)\n        elif self.state.type == "healed":\n            self.color = (255, 255, 255)\n        elif self.state.type == "normal":\n            self.color = (255, 0, 0)\n        elif self.state.type == "vaccinated":\n            self.color = (0, 255, 0)\n        elif self.state.type == "dead":\n            self.color = (50, 50, 50)\n\n        self.move(model.data.peopleSpeed)\n        self.changeGoto(model.sizeX, model.sizeY)\n        \n        # Events if type is alive\n        if self.state.type != "dead":\n            self.state.step(model, debugMode, self.id)\n            self.checkColision(model, debugMode)\n\n    def move(self, speed):\n        self.lastX = dc(self.x)\n        self.lastY = dc(self.y)\n\n        distanceX = self.gotoX - self.x\n        distanceY = self.gotoY - self.y\n\n        distance = sqrt(distanceX * distanceX + distanceY * distanceY)\n\n        try:\n            moveX = distanceX / distance\n        except ZeroDivisionError:\n            moveX = 0\n        try:\n            moveY = distanceY / distance\n        except ZeroDivisionError:\n            moveY = 0\n        moveX *= speed\n        moveY *= speed\n\n        self.x += moveX\n        self.y += moveY\n\n    def checkColision(self, model, debugMode):\n        distanceData = modules.peopleDistance(model.people)\n        for personKey in distanceData[self.id]:\n            if distanceData[self.id][personKey] < model.data.peopleSize * 2 + 4: # *2 is because its two people, so once for the distance from the center to the edge and again for the second +4 is for the thickness\n                touchedPerson = modules.personWithId(model.people, personKey)\n\n                if touchedPerson.state.type == "dead":\n                    continue\n\n                self.x = dc(self.lastX)\n                self.y = dc(self.lastY)\n                self.forceChangeGoto(model.sizeX, model.sizeY)\n\n                if self.state.canBeInfected:\n                    if touchedPerson.state.canInfect:\n                        self.state.type = "infected"\n                        self.state.canBeInfected = False\n                        self.state.canInfect = modules.randomChance(model.data.infectiveChance)\n                        self.state.timeTillChange = time() + model.data.infectedTime + model.randomness()\n\n                        if debugMode:\n                            print(f"Person {self.id} changed type from normal to infected")\n\n                return    \n\n        if modules.wallColiding(model.collisionCanvas, int(self.x), int(self.y)):\n            self.x = dc(self.lastX)\n            self.y = dc(self.lastY)\n            self.forceChangeGoto(model.sizeX, model.sizeY)\n            return\n\n    def changeGoto(self, sizeX, sizeY):\n        if modules.pointDistance(self.x, self.y, self.gotoX, self.gotoY) < 1:\n            self.gotoX = randint(0, sizeX - 1)\n            self.gotoY = randint(0, sizeY - 1)\n\n    def forceChangeGoto(self, sizeX, sizeY):\n        self.gotoX = randint(0, sizeX - 1)\n        self.gotoY = randint(0, sizeY - 1)\n\nclass ModelData():\n    def __init__(self):\n        # People data\n        self.peopleSize = None\n        self.people = None\n        self.peopleSpeed = None\n\n        # Area data\n        self.areaEvenlySplit = None\n        self.areas = None\n\n        # Other data\n        self.randomness = None\n        self.healedTime = None\n        self.infectedTime = None\n        self.vaccineTime = None\n        self.infectiveChance = 100\n        self.lethalityChance = 0\n\nclass Model:\n    def __init__(self):\n        self.sizeX = None\n        self.sizeY = None\n        self.canvas = None\n        self.collisionCanvas = None\n        self.people = []\n        self.data = ModelData()\n\n    def randomness(self):\n        value = random()\n        value *= (self.data.randomness * 2) # self.data.randomness * 2 is so you can subtract randomness and get a number between -randomness and randomness\n        value -= self.data.randomness\n\n        return value\n', 'data.py': 'startLogo = """██████╗░██╗░░░██╗░░░░░░██████╗░███████╗███╗░░░███╗██╗░█████╗░\n██╔══██╗╚██╗░██╔╝░░░░░░██╔══██╗██╔════╝████╗░████║██║██╔══██╗\n██████╔╝░╚████╔╝░█████╗██║░░██║█████╗░░██╔████╔██║██║██║░░╚═╝\n██╔═══╝░░░╚██╔╝░░╚════╝██║░░██║██╔══╝░░██║╚██╔╝██║██║██║░░██╗\n██║░░░░░░░░██║░░░░░░░░░██████╔╝███████╗██║░╚═╝░██║██║╚█████╔╝\n╚═╝░░░░░░░░╚═╝░░░░░░░░░╚═════╝░╚══════╝╚═╝░░░░░╚═╝╚═╝░╚════╝░\n"""\nversion = 5\n', 'main.py': 'import modules\nimport requirements\nimport autoUpdater\nimport data\nfrom os import system\nfrom cv2 import imshow, waitKey, destroyAllWindows\nfrom sys import argv\n\nif autoUpdater.verify():\n    exit()\nrequirements.verify()\n\n# Starting arguments\n# Help menu\nif "--help" in argv or "-h" in argv:\n    print(data.startLogo)\n    print("""\nSyntax:\n[python] ./main.py [arguments]\n          \n-h      displays this help menu\n--help  displays this help menu\n-c      enables the displaying of color\n--color enables the displaying of color\n-m      loads the provided model in the next argument on start\n--model loads the provided model in the next argument on start\n""")\n    exit()\n\n# Enable colors\nif "--color" in argv or "-c" in argv:\n    colorEnabled = True\nelse:\n    colorEnabled = False\n\n# Load a model on start\nif "--model" in argv:\n    overrideModel = argv[argv.index("--model") + 1] # Gets the next param\nelif "-m" in argv:\n    overrideModel = argv[argv.index("-m") + 1] # Gets the next param\nelse:\n    overrideModel = None\n\n# Debug info\nif "--debug" in argv or "-d" in argv:\n    debugMode = True\nelse:\n    debugMode = False\n\n# If an override model param is set, skip the model choosing bit\nif not overrideModel:\n    # Print logo\n    system("cls")\n    modules.colorPrint(data.startLogo, "GREEN", colorEnabled)\n    print("Now with arguments! Start it via command prompt with the -h argument")\n    print()\n\n    # Get all available models (*.json)\n    models = modules.getModels()\n\n    # Print available models\n    modules.colorPrint("Available models:", "CYAN", colorEnabled)\n    for index, model in enumerate(models):\n        modules.colorPrint(f"{index}) {model}", "YELLOW", colorEnabled)\n\n    chosenModel = modules.intInput("Enter the model number to load >>>", f"0:{len(models) - 1}") # User input must be a number between 0 and number of models - 1\n\n    system("cls")\n    \n    model = modules.openModel(models[chosenModel])\nelse:\n    system("cls")\n    model = modules.openModel(overrideModel)\n\nmodules.colorPrint("Spawning people...", "GREEN", colorEnabled)\nmodel = modules.spawnPeople(model)\nmodules.colorPrint("Spawned people!", "PINK", colorEnabled)\nmodules.colorPrint("Simulating...", "GREEN", colorEnabled)\n\nwhile True:\n    canvas = modules.drawPeople(model)\n\n    # Update each person\n    for person in model.people:\n        person.step(model, debugMode)\n\n    imshow("Simulation", canvas)\n\n    if waitKey(1) == ord("q"):\n        break\n\ndestroyAllWindows()\n\n# Log simulation results\nalivePeople = 0\ndeadPeople = 0\nnormalPeople = 0\nvaccinatedPeople = 0\ninfectedPeople = 0\nhealedPeople = 0\n\nfor person in model.people:\n    if person.state.type == "dead":\n        deadPeople += 1\n    elif person.state.type == "normal":\n        alivePeople += 1\n        normalPeople += 1\n    elif person.state.type == "vaccinated":\n        alivePeople += 1\n        vaccinatedPeople += 1\n    elif person.state.type == "infected":\n        alivePeople += 1\n        infectedPeople += 1\n    elif person.state.type == "healed":\n        alivePeople += 1\n        healedPeople += 1\n\nif not debugMode:\n    system("cls")\nmodules.colorPrint("Simulation results:", "BLUE", colorEnabled)\nmodules.colorPrint(f"Total alive people: {alivePeople}", "GREEN", colorEnabled)\nmodules.colorPrint(f"Dead people:        {deadPeople}", "GRAY", colorEnabled)\nmodules.colorPrint(f"Normal people:      {normalPeople}", "BLUE", colorEnabled)\nmodules.colorPrint(f"Vaccinated people:  {vaccinatedPeople}", "GREEN", colorEnabled)\nmodules.colorPrint(f"Infected people:    {infectedPeople}", "RED", colorEnabled)\nmodules.colorPrint(f"Healed people:      {healedPeople}", "WHITE", colorEnabled)\n', 'modules.py': 'import classes\nfrom os import listdir\nfrom numpy import zeros, uint8\nfrom cv2 import line, circle, rectangle\nfrom copy import deepcopy as dc\nfrom random import randint, random\nfrom math import sqrt\nfrom time import time\n\ncolors = {\n    "GRAY": "\\033[90m",\n    "RED": "\\033[91m",\n    "GREEN": "\\033[92m",\n    "YELLOW": "\\033[93m",\n    "BLUE": "\\033[94m",\n    "PINK": "\\033[95m",\n    "CYAN": "\\033[96m",\n    "WHITE": "\\033[97m"\n}\n\ndef colorPrint(text, color, enable):\n    if enable:\n        print(colors[color] + text + colors["WHITE"])\n    else:\n        print(text)\n\ndef intInput(prompt, constraintRange):\n    orgConstraintRange = dc(constraintRange)\n    constraintRange = constraintRange.split(":")\n    constraintRange = list(map(int, constraintRange))\n    userInput = input(prompt)\n\n    try:\n        userInput = int(userInput)\n        if constraintRange[0] <= userInput <= constraintRange[1]:\n            return userInput\n        else:\n            print("Invalid input!")\n            return intInput(prompt, orgConstraintRange)\n    except ValueError:\n        print("Invalid input!")\n        return intInput(prompt, orgConstraintRange)\n\ndef blankCanvas(sizeX, sizeY, colors=3):\n    return zeros((sizeY, sizeX, colors), uint8)\n\ndef getModels():\n    files = []\n\n    for file in listdir():\n        if file.endswith(".json"):\n            files.append(file)\n\n    return files\n\ndef _dictKeyExists(dict, key):\n    if key in list(dict.keys()):\n        return True\n    \n    return False\n\ndef _dictMissingKey(dict, key):\n    if key in list(dict.keys()):\n        return\n    \n    print(f"Model missing value \'{key}\'")\n    exit()\n\ndef openModel(modelName):\n    print(f"Loading model \'{modelName}\'. Please wait...")\n\n    try:\n        with open(modelName, "r") as model:\n            # Load model as dictionary\n            jsonModel = model.readlines()\n            jsonModel = "".join(jsonModel)\n            jsonModel = jsonModel.replace("true", "True")\n            jsonModel = jsonModel.replace("false", "False")\n            jsonModel = eval(jsonModel)\n    except FileNotFoundError:\n        print(f"No model found in the current directory by the name of \'{modelName}\'")\n        exit()\n        \n    model = classes.Model()\n\n    # Notify the user if the needed variables are missing\n    _dictMissingKey(jsonModel, "size_x")\n    _dictMissingKey(jsonModel, "size_y")\n\n    model.sizeX       =   jsonModel["size_x"]\n    model.sizeY       =   jsonModel["size_y"]\n    canvas            =   blankCanvas(jsonModel["size_x"], jsonModel["size_y"])\n    collisionCanvas   =   blankCanvas(jsonModel["size_x"], jsonModel["size_y"])\n\n    # Needed earlier than definition, so check if it exists\n    _dictMissingKey(jsonModel, "people_scale")\n\n    # Check if to draw lines\n    if _dictKeyExists(jsonModel, "lines"):\n        for drawLine in jsonModel["lines"]:\n            # Notify the user if the needed variables are missing\n            _dictMissingKey(drawLine, "P1")\n            _dictMissingKey(drawLine, "P2")\n            _dictMissingKey(drawLine, "color")\n            _dictMissingKey(drawLine, "thickness")\n\n            # Clamp values between 0 and edges\n            clampedAX = max(0, min(drawLine["P1"][0] - jsonModel["people_scale"] - 2, jsonModel["size_x"] - 1)) # -2 is for thickness\n            clampedAY = max(0, min(drawLine["P1"][1] - jsonModel["people_scale"] - 2, jsonModel["size_y"] - 1)) # -2 is for thickness\n            clampedBX = max(0, min(drawLine["P2"][0] + jsonModel["people_scale"] + 2, jsonModel["size_x"] - 1)) # +2 is for thickness\n            clampedBY = max(0, min(drawLine["P2"][1] + jsonModel["people_scale"] + 2, jsonModel["size_y"] - 1)) # +2 is for thickness\n\n            correctedColor    =   (drawLine["color"][2], drawLine["color"][1], drawLine["color"][0]) # Input is in RGB format, opencv uses BGR format\n            canvas            =   line(canvas, drawLine["P1"], drawLine["P2"], correctedColor, drawLine["thickness"])\n            collisionCanvas   =   rectangle(collisionCanvas, (clampedAX, clampedAY), (clampedBX, clampedBY), (255, 255, 255), 2)\n\n    # Copy data from the json model to the python model\n    model.canvas            =   canvas\n    model.collisionCanvas   =   collisionCanvas\n\n    # Notify the user if the needed variables are missing\n    _dictMissingKey(jsonModel, "people")\n    _dictMissingKey(jsonModel, "travel_speed")\n\n    # Copy data from the json model to the python model\n    model.data.people        =   jsonModel["people"]\n    model.data.peopleSize    =   jsonModel["people_scale"]\n    model.data.peopleSpeed   =   jsonModel["travel_speed"]\n\n    # Notify the user if the needed variables are missing\n    _dictMissingKey(jsonModel, "spawn")\n\n    # Copy data from the json model to the python model\n    model.data.areas = jsonModel["spawn"]\n\n    # Notify the user if the needed variables are missing\n    _dictMissingKey(jsonModel, "randomness")\n    _dictMissingKey(jsonModel, "healed_time")\n    _dictMissingKey(jsonModel, "infected_time")\n\n    # Copy data from the json model to the python model\n    model.data.randomness     =   jsonModel["randomness"]\n    model.data.healedTime     =   jsonModel["healed_time"]\n    model.data.infectedTime   =   jsonModel["infected_time"]\n\n    # Other non essential data\n    if _dictKeyExists(jsonModel, "infective_chance"):\n        model.data.infectiveChance = jsonModel["infective_chance"]\n    if _dictKeyExists(jsonModel, "lethality_chance"):\n        model.data.lethalityChance = jsonModel["lethality_chance"]\n    if _dictKeyExists(jsonModel, "vaccine_time"):\n        model.data.vaccineTime = jsonModel["vaccine_time"]\n\n    print("Model loaded!")\n\n    return model\n\ndef peopleDistance(people: classes.Model): #, personId: tuple[int, int] = None): # classes.Model.people must be provided for the variable \'people\'\n    #if not personId:\n        distance = {}\n\n        for personA in people:\n            # Create the distance dictionary for personA\n            distance[personA.id] = {}\n\n            for personB in people:\n                if personA.id == personB.id:\n                    # Same person\n                    continue\n\n                distanceX = abs(personA.x - personB.x)\n                distanceY = abs(personA.y - personB.y)\n\n                distanceTotal = sqrt(distanceX * distanceX + distanceY * distanceY)\n\n                distance[personA.id][personB.id] = distanceTotal\n\n        return distance\n\n    #else:\n    #    # Get the Person class containing the id from \'personId\'\n    #    personA = None\n    #    personB = None\n    #\n    #    for person in people:\n    #        if person.id == personId[0]:\n    #            personA = person\n    #        elif person.id == personId[1]:\n    #            personB = person\n    #\n    #    distanceX = abs(personA.x - personB.x)\n    #    distanceY = abs(personA.y - personB.y)\n    #\n    #    distanceTotal = sqrt(distanceX * distanceX + distanceY * distanceY)\n    #\n    #    return distanceTotal\n\ndef wallColiding(canvas, posX, posY):\n    if canvas[posY][posX][0] == 0 and canvas[posY][posX][1] == 0 and canvas[posY][posX][2] == 0:\n        return False\t\n    \n    return True\n\ndef pointDistance(AX, AY, BX, BY):\n    distanceX = abs(AX - BX)\n    distanceY = abs(AY - BY)\n\n    distance = sqrt(distanceX * distanceX + distanceY * distanceY)\n\n    return distance\n\ndef spawnPeople(model):\n    tooLongTimeDisplayed = False\n\n    lastId = -1\n\n    for area in model.data.areas:\n        peopleInArea = int(model.data.people * (area["probability"] / 100)) # Calculate the amount of people for each area if splitting evenly by the probability\n\n        for personId in range(peopleInArea):\n            tooLongTime = time() + 5\n\n            personId += lastId + 1 # If the last id was for example 3, then a new area is selected, the personId will be 0, so personId + lastId will be 3, but that person already exists, so we add 1\n\n            while True:\n                if time() > tooLongTime and not tooLongTimeDisplayed:\n                    print("This is taking a long time, make sure that there is enough space to spawn all people without them touching, or try to restart the simulation!")\n                    tooLongTimeDisplayed = True\n\n                posX = randint(area["start"][0], area["end"][0] - 1)\n                posY = randint(area["start"][1], area["end"][1] - 1)\n\n                tooClose = False\n\n                # Create a temporary model where the new person is spawned to see if its too close\n                modelAditionalPeople = dc(model)\n                tmpPerson = classes.Person()\n                tmpPerson.x = posX\n                tmpPerson.y = posY\n                tmpPerson.id = personId\n                modelAditionalPeople.people.append(tmpPerson)\n\n                distanceData = peopleDistance(modelAditionalPeople.people)\n                for personDistanceKey in distanceData:\n                    if _dictKeyExists(distanceData[personDistanceKey], personId):\n                        if distanceData[personDistanceKey][personId] <= model.data.peopleSize * 2 + 4: # *2 because *1 is only half of the circle, +4 for line thickness\n                            tooClose = True\n                            break\n                \n                if wallColiding(model.canvas, posX, posY):\n                    tooClose = True\n\n                if not tooClose:\n                    person = classes.Person()\n                    person.id = personId\n                    person.x = posX\n                    person.y = posY\n                    person.lastX = posX\n                    person.lastY = posY\n                    person.gotoX = posX\n                    person.gotoY = posY\n                    if _dictKeyExists(area, "infected"):\n                        if area["infected"]:\n                            person.state.type = "infected"\n                            person.state.canBeInfected = False\n                            person.state.canInfect = randomChance(model.data.infectiveChance)\n                            person.state.timeTillChange = time() + model.data.infectedTime + model.randomness()\n                            person.color = (0, 0, 255)\n                    elif _dictKeyExists(area, "vaccinated"):\n                        if area["vaccinated"]:\n                            person.state.type = "vaccinated"\n                            person.state.canBeInfected = False\n                            person.state.canInfect = False\n                            person.color = (0, 255, 0)\n\n                            if model.data.vaccineTime:\n                                person.state.vaccineInfinite = False\n                                person.state.timeTillChange = time() + model.data.vaccineTime + model.randomness()\n\n                    model.people.append(person)\n\n                    break\n\n        lastId = dc(personId)\n\n    return model\n\ndef drawPeople(model: classes.Model):\n    model = dc(model) # Changes the same variable in an alternate memory space so it doesnt change in the main.py program\n\n    for person in model.people:\n        model.canvas = circle(model.canvas, (int(person.x), int(person.y)), model.data.peopleSize, person.color, 4)\n\n    return model.canvas\n\ndef personWithId(people: classes.Model, id): # classes.Model.people\n    for person in people:\n        if person.id == id:\n            return person\n        \n    return None\n\ndef randomChance(chance):\n    randomNum = random() * 100\n    \n    if randomNum <= chance:\n        return True\n    \n    return False\n', 'requirements.py': 'def verify():\n    try:\n        import cv2\n    except:\n        from os import system\n\n        print("Please wait...")\n\n        system("pip install opencv-python")\n\n        system("cls")\n'}
print("Unpacking py-demic...")

for key in data:
    if key != "name":
        print(f"Unpacking {key}")
        with open(key, "w", encoding="utf8") as file:
            file.write(data[key])

import os

os.startfile("main.py")
