data = {'autoUpdater.py': 'from data import version\nfrom urllib.request import urlopen as uo\nfrom os import startfile, remove\nfrom os.path import exists\n\nupdaterCode = """\nfrom urllib.request import urlopen as uo\nimport time\n\ntime.sleep(1)\n\ndownloadUrl = "https://raw.githubusercontent.com/GabbaTK/Py-demic-2024/main/unpack_py-demic.py"\n\ndownload = uo(downloadUrl)\ndownload = download.read()\nexec(download)\n"""\nversionUrl = "https://raw.githubusercontent.com/GabbaTK/Py-demic-2024/main/version.txt"\n\ndef verify():\n    newVersion = uo(versionUrl)\n    newVersion = eval(newVersion.read())\n    \n    if newVersion > version:\n        print("A new version has been found, downloading...")\n\n        with open("update.py", "w") as update:\n            update.write(updaterCode)\n\n        startfile("update.py")\n    else:\n        if exists("update.py"):\n            remove("update.py")\n', 'blank.json': '{\n    "size_x": 500,\n    "size_y": 500,\n    "people_scale": 10,\n    "people": 20,\n    "travel_speed": 2,\n    "randomness": 5,\n    "healed_time": 20,\n    "infected_time": 20,\n    "lines": [],\n    "spawn": [\n        {"start": [0, 0], "end": [100, 100], "probability": 25},\n        {"start": [400, 0], "end": [500, 100], "probability": 25},\n        {"start": [0, 400], "end": [100, 500], "probability": 25, "vaccinated": "t"},\n        {"start": [400, 400], "end": [500, 500], "probability": 25, "infected": "t"}\n    ]\n}', 'classes.py': 'from math import sqrt\nfrom time import time\nfrom random import random, randint\nfrom copy import deepcopy as dc\nimport modules\n\nclass State:\n    def __init__(self):\n        self.type = "normal"\n        self.canInfect = False\n        self.canBeInfected = True\n        self.timeTillChange = 0\n\n    def step(self):\n        if self.timeTillChange < time():\n            if self.type == "infected":\n                self.canInfect = False\n                self.canBeInfected = False\n            elif self.type == "healed":\n                self.canInfect = False\n                self.canBeInfected = True\n\nclass Person:\n    def __init__(self):\n        self.id = 0\n        self.x = None\n        self.y = None\n        self.lastX = None\n        self.lastY = None\n        self.gotoX = None\n        self.gotoY = None\n        self.color = (255, 0, 0) # BGR\n        self.state = State()\n\n    def step(self, speed, sizeX, sizeY):\n        self.state.step()\n        self.changeGoto(sizeX, sizeY)\n        self.move(speed)\n\n    def move(self, speed):\n        self.lastX = dc(self.x)\n        self.lastY = dc(self.y)\n\n        distanceX = self.gotoX - self.x\n        distanceY = self.gotoY - self.y\n\n        distance = sqrt(distanceX * distanceX + distanceY * distanceY)\n\n        moveX = distanceX / distance\n        moveY = distanceY / distance\n        moveX *= speed\n        moveY *= speed\n\n        self.x += moveX\n        self.y += moveY\n\n    def changeGoto(self, sizeX, sizeY):\n        if modules.pointDistance(self.x, self.y, self.gotoX, self.gotoY) < 1:\n            self.gotoX = randint(0, sizeX)\n            self.gotoY = randint(0, sizeY)\n\nclass ModelData():\n    def __init__(self):\n        # People data\n        self.peopleSize = None\n        self.people = None\n        self.peopleSpeed = None\n\n        # Area data\n        self.areaEvenlySplit = None\n        self.areas = None\n\n        # Other data\n        self.randomness = None\n        self.healedTime = None\n        self.infectedTime = None\n\nclass Model:\n    def __init__(self):\n        self.sizeX = None\n        self.sizeY = None\n        self.canvas = None\n        self.people = []\n        self.data = ModelData()\n\n    def randomness(self):\n        value = random()\n        value *= (self.data.randomness * 2) # self.data.randomness * 2 is so you can subtract randomness and get a number between -randomness and randomness\n        value -= self.data.randomness\n\n        return value\n', 'data.py': 'startLogo = """██████╗░██╗░░░██╗░░░░░░██████╗░███████╗███╗░░░███╗██╗░█████╗░\n██╔══██╗╚██╗░██╔╝░░░░░░██╔══██╗██╔════╝████╗░████║██║██╔══██╗\n██████╔╝░╚████╔╝░█████╗██║░░██║█████╗░░██╔████╔██║██║██║░░╚═╝\n██╔═══╝░░░╚██╔╝░░╚════╝██║░░██║██╔══╝░░██║╚██╔╝██║██║██║░░██╗\n██║░░░░░░░░██║░░░░░░░░░██████╔╝███████╗██║░╚═╝░██║██║╚█████╔╝\n╚═╝░░░░░░░░╚═╝░░░░░░░░░╚═════╝░╚══════╝╚═╝░░░░░╚═╝╚═╝░╚════╝░\n"""\nversion = 3\n', 'main.py': 'import modules\nimport requirements\nimport autoUpdater\nimport data\nfrom os import system\nfrom cv2 import imshow, waitKey, destroyAllWindows\nfrom time import time_ns as tmns\n\nautoUpdater.verify()\nrequirements.verify()\n\ntimeLastFrame = None\ndeltaTime = 0\n\n# Print logo\nsystem("cls")\nprint(data.startLogo)\nprint()\n\n# Get all available models (*.json)\nmodels = modules.getModels()\n\n# Print available models\nprint("Available models:")\nfor index, model in enumerate(models):\n    print(f"{index}) {model}")\n\nchosenModel = modules.intInput("Enter the model number to load >>>", f"0:{len(models) - 1}") # User input must be a number between 0 and number of models - 1\n\nsystem("cls")\nmodel = modules.openModel(models[chosenModel])\nprint("Spawning people...")\nmodel = modules.spawnPeople(model)\nprint("Spawned people!")\nprint("Simulating...")\n\nwhile True:\n    timeLastFrame = tmns()\n\n    canvas = modules.drawPeople(model)\n\n    # Move each person\n    for person in model.people:\n        person.step(model.data.peopleSpeed, model.sizeX, model.sizeY)\n\n    imshow("Simulation", canvas)\n\n    if waitKey(1) == ord("q"):\n        break\n\ndestroyAllWindows()\n', 'modules.py': 'import classes\nimport data\nfrom os import listdir\nfrom numpy import zeros\nfrom cv2 import line, circle\nfrom copy import deepcopy as dc\nfrom random import randint\nfrom math import sqrt, floor\nfrom time import time\n\ndef intInput(prompt, constraintRange):\n    orgConstraintRange = dc(constraintRange)\n    constraintRange = constraintRange.split(":")\n    constraintRange = list(map(int, constraintRange))\n    userInput = input(prompt)\n\n    try:\n        userInput = int(userInput)\n        if constraintRange[0] <= userInput <= constraintRange[1]:\n            return userInput\n        else:\n            print("Invalid input!")\n            return intInput(prompt, orgConstraintRange)\n    except ValueError:\n        print("Invalid input!")\n        return intInput(prompt, orgConstraintRange)\n\ndef blankCanvas(sizeX, sizeY, colors=3):\n    return zeros((sizeY, sizeX, colors))\n\ndef getModels():\n    files = []\n\n    for file in listdir():\n        if file.endswith(".json"):\n            files.append(file)\n\n    return files\n\ndef _dictKeyExists(dict, key):\n    if key in list(dict.keys()):\n        return True\n    \n    return False\n\ndef _dictMissingKey(dict, key):\n    if key in list(dict.keys()):\n        return\n    \n    print(f"Model missing value \'{key}\'")\n    exit()\n\ndef openModel(modelName):\n    print(f"Loading model \'{modelName}\'. Please wait...")\n\n    with open(modelName, "r") as model:\n        # Load model as dictionary\n        jsonModel = model.readlines()\n        jsonModel = "".join(jsonModel)\n        jsonModel = jsonModel.replace("true", "True")\n        jsonModel = jsonModel.replace("false", "False")\n        jsonModel = eval(jsonModel)\n        \n    model = classes.Model()\n\n    # Notify the user if the needed variables are missing\n    _dictMissingKey(jsonModel, "size_x")\n    _dictMissingKey(jsonModel, "size_y")\n\n    model.sizeX   =   jsonModel["size_x"]\n    model.sizeY   =   jsonModel["size_y"]\n    canvas        =   blankCanvas(jsonModel["size_x"], jsonModel["size_y"])\n\n    # Check if to draw lines\n    if _dictKeyExists(jsonModel, "lines"):\n        for drawLine in jsonModel["lines"]:\n            # Notify the user if the needed variables are missing\n            _dictMissingKey(drawLine, "P1")\n            _dictMissingKey(drawLine, "P2")\n            _dictMissingKey(drawLine, "color")\n            _dictMissingKey(drawLine, "thickness")\n\n            canvas = line(canvas, drawLine["P1"], drawLine["P2"], drawLine["color"], drawLine["thickness"])\n\n    # Copy data from the json model to the python model\n    model.canvas = canvas\n\n    # Notify the user if the needed variables are missing\n    _dictMissingKey(jsonModel, "people")\n    _dictMissingKey(jsonModel, "people_scale")\n    _dictMissingKey(jsonModel, "travel_speed")\n\n    # Copy data from the json model to the python model\n    model.data.people        =   jsonModel["people"]\n    model.data.peopleSize    =   jsonModel["people_scale"]\n    model.data.peopleSpeed   =   jsonModel["travel_speed"]\n\n    # Notify the user if the needed variables are missing\n    _dictMissingKey(jsonModel, "spawn")\n\n    # Copy data from the json model to the python model\n    model.data.areas = jsonModel["spawn"]\n\n    # Notify the user if the needed variables are missing\n    _dictMissingKey(jsonModel, "randomness")\n    _dictMissingKey(jsonModel, "healed_time")\n    _dictMissingKey(jsonModel, "infected_time")\n\n    # Copy data from the json model to the python model\n    model.data.randomness     =   jsonModel["randomness"]\n    model.data.healedTime     =   jsonModel["healed_time"]\n    model.data.infectedTime   =   jsonModel["infected_time"]\n\n    print("Model loaded!")\n\n    return model\n\ndef _peopleDistance(people: classes.Model): #, personId: tuple[int, int] = None): # classes.Model.people must be provided for the variable \'people\'\n    #if not personId:\n        distance = {}\n\n        for personA in people:\n            # Create the distance dictionary for personA\n            distance[personA.id] = {}\n\n            for personB in people:\n                if personA.id == personB.id:\n                    # Same person\n                    continue\n\n                distanceX = abs(personA.x - personB.x)\n                distanceY = abs(personA.y - personB.y)\n\n                distanceTotal = sqrt(distanceX * distanceX + distanceY * distanceY)\n\n                distance[personA.id][personB.id] = distanceTotal\n\n        return distance\n\n    #else:\n    #    # Get the Person class containing the id from \'personId\'\n    #    personA = None\n    #    personB = None\n    #\n    #    for person in people:\n    #        if person.id == personId[0]:\n    #            personA = person\n    #        elif person.id == personId[1]:\n    #            personB = person\n    #\n    #    distanceX = abs(personA.x - personB.x)\n    #    distanceY = abs(personA.y - personB.y)\n    #\n    #    distanceTotal = sqrt(distanceX * distanceX + distanceY * distanceY)\n    #\n    #    return distanceTotal\n\ndef _wallColiding(canvas, posX, posY):\n    if canvas[posY][posX][0] == 0 and canvas[posY][posX][1] == 0 and canvas[posY][posX][2] == 0:\n        return False\t\n    \n    return True\n\ndef pointDistance(AX, AY, BX, BY):\n    distanceX = abs(AX - BX)\n    distanceY = abs(AY - BY)\n\n    distance = sqrt(distanceX * distanceX + distanceY * distanceY)\n\n    return distance\n\ndef spawnPeople(model):\n    tooLongTimeDisplayed = False\n\n    lastId = -1\n\n    for area in model.data.areas:\n        peopleInArea = int(model.data.people * (area["probability"] / 100)) # Calculate the amount of people for each area if splitting evenly by the probability\n\n        for personId in range(peopleInArea):\n            tooLongTime = time() + 5\n\n            personId += lastId + 1 # If the last id was for example 3, then a new area is selected, the personId will be 0, so personId + lastId will be 3, but that person already exists, so we add 1\n\n            while True:\n                if time() > tooLongTime and not tooLongTimeDisplayed:\n                    print("This is taking a long time, make sure that there is enough space to spawn all people without them touching, or try to restart the simulation!")\n                    tooLongTimeDisplayed = True\n\n                posX = randint(area["start"][0], area["end"][0] - 1)\n                posY = randint(area["start"][1], area["end"][1] - 1)\n\n                tooClose = False\n\n                # Create a temporary model where the new person is spawned to see if its too close\n                modelAditionalPeople = dc(model)\n                tmpPerson = classes.Person()\n                tmpPerson.x = posX\n                tmpPerson.y = posY\n                tmpPerson.id = personId\n                modelAditionalPeople.people.append(tmpPerson)\n\n                distanceData = _peopleDistance(modelAditionalPeople.people)\n                for personDistanceKey in distanceData:\n                    if _dictKeyExists(distanceData[personDistanceKey], personId):\n                        if distanceData[personDistanceKey][personId] <= model.data.peopleSize * 2 + 4: # *2 because *1 is only half of the circle, +4 for line thickness\n                            tooClose = True\n                            break\n                \n                if _wallColiding(model.canvas, posX, posY):\n                    tooClose = True\n\n                if not tooClose:\n                    person = classes.Person()\n                    person.id = personId\n                    person.x = posX\n                    person.y = posY\n                    person.lastX = posX\n                    person.lastY = posY\n                    person.gotoX = posX\n                    person.gotoY = posY\n                    if _dictKeyExists(area, "infected"):\n                        person.state.type = "infected"\n                        person.state.canBeInfected = False\n                        person.state.canInfect = True\n                        person.state.timeTillChange = time() + model.data.infectedTime + model.randomness()\n                        person.color = (0, 0, 255)\n                    elif _dictKeyExists(area, "vaccinated"):\n                        person.state.type = "vaccinated"\n                        person.state.canBeInfected = False\n                        person.state.canInfect = False\n                        person.color = (0, 255, 0)\n\n                    model.people.append(person)\n\n                    break\n\n    return model\n\ndef drawPeople(model: classes.Model):\n    model = dc(model) # Changes the same variable in an alternate memory space so it doesnt change in the main.py program\n\n    for person in model.people:\n        model.canvas = circle(model.canvas, (int(person.x), int(person.y)), model.data.peopleSize, person.color, 4)\n\n    return model.canvas\n', 'requirements.py': 'def verify():\n    try:\n        import cv2\n    except:\n        from os import system\n\n        print("Please wait...")\n\n        system("pip install opencv-python")\n\n        system("cls")\n'}
print("Unpacking py-demic...")

for key in data:
    if key != "name":
        print(f"Unpacking {key}")
        with open(key, "w", encoding="utf8") as file:
            file.write(data[key])

import os

os.startfile("main.py")
